---
icon: basil:edit-solid
date: 2025-04-19
isOriginal: true
category:
  - frontend
  - nextjs
tag:
  - nextjs
---

前端发展的太快了...

<!-- more -->

# 为什么你应该开始使用 Turbo 开发前端

前端开发这几年变化很快，从单页应用（SPA）到服务端渲染（SSR），从 webpack 到 Vite，再到各种组件库和构建工具的百花齐放，开发者每天都在拥抱新工具。而在管理项目结构、依赖、构建优化这些“工程化”方面，很多人其实还在用最基础的做法。

直到我遇到了 Turbo。我想分享的是我为什么逐渐把一些项目迁移到 Turbo 下的，过程中踩过什么坑，它到底能帮我们解决哪些问题

## 1. 前端开发的 *正常流程* (你可能已经习惯了的混乱)

绝大多数团队（尤其是中小型）做前端项目时，基本是这样一套流程：

每个项目一个独立仓库

每个仓库里安装一套依赖（React、Webpack、ESLint、Prettier 等）

每个项目写自己的脚本、自己的构建逻辑、自己的 CI/CD 配置

本地开发时，各自 npm start 或 yarn dev

有人提了需求，就在自己的项目里改，然后发 PR，合并，部署

这种方式的优点是简单直观，但一旦项目一多，问题就来了。

## 2. 常见流程的痛点

> 重复劳动严重
每个项目都要写一遍 ESLint 配置？Prettier 配置？Jest 配置？React 脚手架？久而久之，一个团队手上有 5 个项目，就有 5 套配置，维护成本翻倍。

> 依赖版本不一致
项目 A 用 React 17，项目 B 升级到 React 18，结果某个组件库版本不兼容，修半天才发现是版本问题。

> 构建缓慢
每个项目构建都要从头来一遍，哪怕只改了一个小文件，CI 上跑半天，部署效率低。

> 缺乏统一管理
跨项目的组件库很难维护：是把组件复制粘贴过去？还是写一个私有 npm 包？都不太理想。

## 3. Turbo 是什么？它能解决这些问题吗？

Turbo，全名是 [Turborepo](https://turbo.build)，是由 Vercel 团队开发的现代 monorepo 构建系统。它不是一个框架，而是一个“工程效率工具”。

它的核心目标是：让你用单一代码仓库（monorepo）高效地管理多个前端（和后端）项目。

Turbo 的核心优势：

> 增量构建与智能缓存
改了哪个包、哪个文件，它就构建对应的内容，其他内容复用缓存。第一次构建慢，第二次飞快，尤其适合 CI/CD。

> 统一依赖和工具链管理
所有项目共享一套 ESLint、Prettier、Jest、Vite、Next 等工具配置，升级一次，全体生效。

> 组件复用更自然
自定义组件库和页面模块可以作为一个 packages/ui 存在，多个项目直接 import 即可，无需发 npm 包。

> 开发体验丝滑
一个命令：turbo dev，就能并行启动多个项目（比如同时启动前端 web 和后端 API 服务）。

> 构建输出定义清晰
每个包的输出目录清楚明了，不会把 build 文件写得满地都是。

哪些项目适合用 Turbo？
- 企业级多产品线（比如 admin、官网、h5、小程序）
- 多平台共用组件的团队（比如 React Web + React Native）
- 有自己组件库的中台系统
- 个人全栈项目：前端、后端、cli 工具都在一个仓库里

目前很多团队、开源项目都在使用 Turbo，例如：

- Vercel 官方的 SDK 管理仓库
- shadcn/ui: 多项目复用 UI 的典范
- Next.js: 内部 monorepo 管理框架代码

### Turbo 的缺点

软件工程没有银弹,没有解决所有问题的最优解.

虽然 Turbo 强大，但初学者在使用时可能会遇到几个问题：

1. 学习成本偏高
如果你之前没有接触过 monorepo 概念（比如 Lerna、Nx 等），一开始可能会被 apps/、packages/、turbo.json 搞晕。

2. 缓存机制有时不明确
Turbo 的缓存依赖于输出目录和依赖 hash，出问题时排查不太直观。

3. 不适合每一个团队
如果你的项目就一个单页面应用（SPA），没那么多共享逻辑，其实没必要搞那么复杂。
