import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{r as l,o as b,c as i,b as o,f as u,e as t,d as r,a as n}from"./app-468a2905.js";const d={},s={href:"https://turbo.build",target:"_blank",rel:"noopener noreferrer"};function c(h,e){const p=l("ExternalLinkIcon");return b(),i("div",null,[e[3]||(e[3]=o("p",null,"前端发展的太快了...",-1)),u(" more "),e[4]||(e[4]=t('<h1 id="为什么你应该开始使用-turbo-开发前端" tabindex="-1"><a class="header-anchor" href="#为什么你应该开始使用-turbo-开发前端" aria-hidden="true">#</a> 为什么你应该开始使用 Turbo 开发前端</h1><p>前端开发这几年变化很快，从单页应用（SPA）到服务端渲染（SSR），从 webpack 到 Vite，再到各种组件库和构建工具的百花齐放，开发者每天都在拥抱新工具。而在管理项目结构、依赖、构建优化这些“工程化”方面，很多人其实还在用最基础的做法。</p><p>直到我遇到了 Turbo。我想分享的是我为什么逐渐把一些项目迁移到 Turbo 下的，过程中踩过什么坑，它到底能帮我们解决哪些问题</p><h2 id="_1-前端开发的-正常流程-你可能已经习惯了的混乱" tabindex="-1"><a class="header-anchor" href="#_1-前端开发的-正常流程-你可能已经习惯了的混乱" aria-hidden="true">#</a> 1. 前端开发的 <em>正常流程</em> (你可能已经习惯了的混乱)</h2><p>绝大多数团队（尤其是中小型）做前端项目时，基本是这样一套流程：</p><p>每个项目一个独立仓库</p><p>每个仓库里安装一套依赖（React、Webpack、ESLint、Prettier 等）</p><p>每个项目写自己的脚本、自己的构建逻辑、自己的 CI/CD 配置</p><p>本地开发时，各自 npm start 或 yarn dev</p><p>有人提了需求，就在自己的项目里改，然后发 PR，合并，部署</p><p>这种方式的优点是简单直观，但一旦项目一多，问题就来了。</p><h2 id="_2-常见流程的痛点" tabindex="-1"><a class="header-anchor" href="#_2-常见流程的痛点" aria-hidden="true">#</a> 2. 常见流程的痛点</h2><blockquote><p>重复劳动严重<br> 每个项目都要写一遍 ESLint 配置？Prettier 配置？Jest 配置？React 脚手架？久而久之，一个团队手上有 5 个项目，就有 5 套配置，维护成本翻倍。</p></blockquote><blockquote><p>依赖版本不一致<br> 项目 A 用 React 17，项目 B 升级到 React 18，结果某个组件库版本不兼容，修半天才发现是版本问题。</p></blockquote><blockquote><p>构建缓慢<br> 每个项目构建都要从头来一遍，哪怕只改了一个小文件，CI 上跑半天，部署效率低。</p></blockquote><blockquote><p>缺乏统一管理<br> 跨项目的组件库很难维护：是把组件复制粘贴过去？还是写一个私有 npm 包？都不太理想。</p></blockquote><h2 id="_3-turbo-是什么-它能解决这些问题吗" tabindex="-1"><a class="header-anchor" href="#_3-turbo-是什么-它能解决这些问题吗" aria-hidden="true">#</a> 3. Turbo 是什么？它能解决这些问题吗？</h2>',17)),o("p",null,[e[1]||(e[1]=r("Turbo，全名是 ")),o("a",s,[e[0]||(e[0]=r("Turborepo")),n(p)]),e[2]||(e[2]=r("，是由 Vercel 团队开发的现代 monorepo 构建系统。它不是一个框架，而是一个“工程效率工具”。"))]),e[5]||(e[5]=t('<p>它的核心目标是：让你用单一代码仓库（monorepo）高效地管理多个前端（和后端）项目。</p><p>Turbo 的核心优势：</p><blockquote><p>增量构建与智能缓存<br> 改了哪个包、哪个文件，它就构建对应的内容，其他内容复用缓存。第一次构建慢，第二次飞快，尤其适合 CI/CD。</p></blockquote><blockquote><p>统一依赖和工具链管理<br> 所有项目共享一套 ESLint、Prettier、Jest、Vite、Next 等工具配置，升级一次，全体生效。</p></blockquote><blockquote><p>组件复用更自然<br> 自定义组件库和页面模块可以作为一个 packages/ui 存在，多个项目直接 import 即可，无需发 npm 包。</p></blockquote><blockquote><p>开发体验丝滑<br> 一个命令：turbo dev，就能并行启动多个项目（比如同时启动前端 web 和后端 API 服务）。</p></blockquote><blockquote><p>构建输出定义清晰<br> 每个包的输出目录清楚明了，不会把 build 文件写得满地都是。</p></blockquote><p>哪些项目适合用 Turbo？</p><ul><li>企业级多产品线（比如 admin、官网、h5、小程序）</li><li>多平台共用组件的团队（比如 React Web + React Native）</li><li>有自己组件库的中台系统</li><li>个人全栈项目：前端、后端、cli 工具都在一个仓库里</li></ul><p>目前很多团队、开源项目都在使用 Turbo，例如：</p><ul><li>Vercel 官方的 SDK 管理仓库</li><li>shadcn/ui: 多项目复用 UI 的典范</li><li>Next.js: 内部 monorepo 管理框架代码</li></ul><h3 id="turbo-的缺点" tabindex="-1"><a class="header-anchor" href="#turbo-的缺点" aria-hidden="true">#</a> Turbo 的缺点</h3><p>软件工程没有银弹,没有解决所有问题的最优解.</p><p>虽然 Turbo 强大，但初学者在使用时可能会遇到几个问题：</p><ol><li><p>学习成本偏高<br> 如果你之前没有接触过 monorepo 概念（比如 Lerna、Nx 等），一开始可能会被 apps/、packages/、turbo.json 搞晕。</p></li><li><p>缓存机制有时不明确<br> Turbo 的缓存依赖于输出目录和依赖 hash，出问题时排查不太直观。</p></li><li><p>不适合每一个团队<br> 如果你的项目就一个单页面应用（SPA），没那么多共享逻辑，其实没必要搞那么复杂。</p></li></ol>',15))])}const q=a(d,[["render",c],["__file","why-you-should-to-use-turbo.html.vue"]]);export{q as default};
