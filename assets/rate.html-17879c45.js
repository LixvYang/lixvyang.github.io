import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as p,o as i,c as l,b as a,d as s,a as t,f as c,e as r}from"./app-f36a79b7.js";const u={},k={href:"http://xn--golang-9v7iwx47ucs0afob15kopb752flcpmsbb49ckjlepxb32ajs3g.org/x/time/rate%E3%80%82%E8%AF%A5%E9%99%90%E6%B5%81%E5%99%A8%E6%98%AF%E5%9F%BA%E4%BA%8E",target:"_blank",rel:"noopener noreferrer"},d={href:"https://www.cyhone.com/articles/usage-of-golang-rate/",target:"_blank",rel:"noopener noreferrer"},m={href:"https://www.cyhone.com/articles/analisys-of-golang-rate/",target:"_blank",rel:"noopener noreferrer"},v={href:"https://www.cyhone.com/articles/analysis-of-uber-go-ratelimit/",target:"_blank",rel:"noopener noreferrer"};function b(g,n){const e=p("ExternalLinkIcon");return i(),l("div",null,[n[6]||(n[6]=a("p",null,"当我们写我们的后台服务时，使用限流器是非常有必要的，限流器可以帮助我们限制请求的速率，保护服务，避免服务过载等。",-1)),a("p",null,[n[1]||(n[1]=s("Golang ")),a("a",k,[n[0]||(n[0]=s("标准库中就自带了限流算法的实现golang.org/x/time/rate。该限流器是基于")),t(e)]),n[2]||(n[2]=s(" Token Bucket(令牌桶) 实现的。"))]),c(" more "),n[7]||(n[7]=r(`<h1 id="time-rate的介绍和使用" tabindex="-1"><a class="header-anchor" href="#time-rate的介绍和使用" aria-hidden="true">#</a> time/rate的介绍和使用</h1><p>简单来说，令牌桶就是想象有一个固定大小的桶，系统会以恒定速率向桶中放 Token，桶满则暂时不放。</p><p>而用户则从桶中取 Token，如果有剩余 Token 就可以一直取。如果没有剩余 Token，则需要等到系统中被放置了 Token 才行。</p><p>本文则主要集中介绍下该组件的具体使用方法：</p><h3 id="构造一个限流器" tabindex="-1"><a class="header-anchor" href="#构造一个限流器" aria-hidden="true">#</a> 构造一个限流器</h3><p>我们可以使用以下方法构造一个限流器对象：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>limiter <span class="token operator">:=</span> <span class="token function">NewLimiter</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这里有两个参数：</p><p>第一个参数是 r Limit。代表每秒可以向 Token 桶中产生多少 token。Limit 实际上是 float64 的别名。<br> 第二个参数是 b int。b 代表 Token 桶的容量大小。<br> 那么，对于以上例子来说，其构造出的限流器含义为，其令牌桶大小为 1, 以每秒 10 个 Token 的速率向桶中放置 Token。</p><p>除了直接指定每秒产生的 Token 个数外，还可以用 Every 方法来指定向 Token 桶中放置 Token 的间隔，例如：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>limit <span class="token operator">:=</span> <span class="token function">Every</span><span class="token punctuation">(</span><span class="token number">100</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span><span class="token punctuation">;</span>
limiter <span class="token operator">:=</span> <span class="token function">NewLimiter</span><span class="token punctuation">(</span>limit<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>以上就表示每 100ms 往桶中放一个 Token。本质上也就是一秒钟产生 10 个。</p><p>Limiter 提供了三类方法供用户消费 Token，用户可以每次消费一个 Token，也可以一次性消费多个 Token。<br> 而每种方法代表了当 Token 不足时，各自不同的对应手段。</p><h3 id="wait-waitn" tabindex="-1"><a class="header-anchor" href="#wait-waitn" aria-hidden="true">#</a> Wait/WaitN</h3><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token punctuation">(</span>lim <span class="token operator">*</span>Limiter<span class="token punctuation">)</span> <span class="token function">Wait</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">(</span>err <span class="token builtin">error</span><span class="token punctuation">)</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>lim <span class="token operator">*</span>Limiter<span class="token punctuation">)</span> <span class="token function">WaitN</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>err <span class="token builtin">error</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>Wait 实际上就是 WaitN(ctx,1)。</p><p>当使用 Wait 方法消费 Token 时，如果此时桶内 Token 数组不足 (小于 N)，那么 Wait 方法将会阻塞一段时间，直至 Token 满足条件。如果充足则直接返回。</p><p>这里可以看到，Wait 方法有一个 context 参数。<br> 我们可以设置 context 的 Deadline 或者 Timeout，来决定此次 Wait 的最长时间。</p><h3 id="allow-allown" tabindex="-1"><a class="header-anchor" href="#allow-allown" aria-hidden="true">#</a> Allow/AllowN</h3><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token punctuation">(</span>lim <span class="token operator">*</span>Limiter<span class="token punctuation">)</span> <span class="token function">Allow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>lim <span class="token operator">*</span>Limiter<span class="token punctuation">)</span> <span class="token function">AllowN</span><span class="token punctuation">(</span>now time<span class="token punctuation">.</span>Time<span class="token punctuation">,</span> n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>Allow 实际上就是 AllowN(time.Now(),1)。</p><p>AllowN 方法表示，截止到某一时刻，目前桶中数目是否至少为 n 个，满足则返回 true，同时从桶中消费 n 个 token。<br> 反之返回不消费 Token，false。</p><p>通常对应这样的线上场景，如果请求速率过快，就直接丢到某些请求。</p><h3 id="reserve-reserven" tabindex="-1"><a class="header-anchor" href="#reserve-reserven" aria-hidden="true">#</a> Reserve/ReserveN</h3><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token punctuation">(</span>lim <span class="token operator">*</span>Limiter<span class="token punctuation">)</span> <span class="token function">Reserve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>Reservation
<span class="token keyword">func</span> <span class="token punctuation">(</span>lim <span class="token operator">*</span>Limiter<span class="token punctuation">)</span> <span class="token function">ReserveN</span><span class="token punctuation">(</span>now time<span class="token punctuation">.</span>Time<span class="token punctuation">,</span> n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">*</span>Reservation
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>Reserve 相当于 ReserveN(time.Now(), 1)。</p><p>ReserveN 的用法就相对来说复杂一些，当调用完成后，无论 Token 是否充足，都会返回一个 Reservation * 对象。</p><p>你可以调用该对象的 Delay() 方法，该方法返回了需要等待的时间。如果等待时间为 0，则说明不用等待。<br> 必须等到等待时间之后，才能进行接下来的工作。</p><p>或者，如果不想等待，可以调用 Cancel() 方法，该方法会将 Token 归还。</p><p>举一个简单的例子，我们可以这么使用 Reserve 方法。</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>r <span class="token operator">:=</span> lim<span class="token punctuation">.</span><span class="token function">Reserve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
f <span class="token operator">!</span>r<span class="token punctuation">.</span><span class="token function">OK</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Not allowed to act! Did you remember to set lim.burst to be &gt; 0 ?</span>
    <span class="token keyword">return</span>
<span class="token punctuation">}</span>
time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token function">Act</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 执行相关逻辑</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="动态调整速率" tabindex="-1"><a class="header-anchor" href="#动态调整速率" aria-hidden="true">#</a> 动态调整速率</h3><p>Limiter 支持可以调整速率和桶大小：</p><p>SetLimit(Limit) 改变放入 Token 的速率<br> SetBurst(int) 改变 Token 桶大小<br> 有了这两个方法，可以根据现有环境和条件以及我们的需求，动态地改变 Token 桶大小和速率。</p><hr><p>本文参考:</p>`,36)),a("ol",null,[a("li",null,[a("a",d,[n[3]||(n[3]=s("https://www.cyhone.com/articles/usage-of-golang-rate/")),t(e)])]),a("li",null,[a("a",m,[n[4]||(n[4]=s("https://www.cyhone.com/articles/analisys-of-golang-rate/")),t(e)])]),a("li",null,[a("a",v,[n[5]||(n[5]=s("https://www.cyhone.com/articles/analysis-of-uber-go-ratelimit/")),t(e)])])])])}const w=o(u,[["render",b],["__file","rate.html.vue"]]);export{w as default};
